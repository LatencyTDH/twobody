<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Two-Body Gravitational Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(40, 40, 40, 0.85);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: grid;
            grid-template-columns: auto 1fr auto; /* Label, Slider, Value */
            align-items: center;
            gap: 10px 15px;
            width: 90%;
            max-width: 450px;
        }
        label {
            color: #e0e0e0;
            font-weight: 500;
            white-space: nowrap;
            text-align: right;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, #4a90e2, #8e44ad); /* Default for G */
            border-radius: 5px;
            cursor: pointer;
            outline: none;
            transition: background .3s;
        }
        input[type="range"].mass1-slider {
             background: linear-gradient(90deg, #ffdf80, #ff8c1a); /* Brighter Yellow/Orange */
        }
         input[type="range"].mass2-slider {
             background: linear-gradient(90deg, #6bbdff, #0099e6); /* Brighter Blue/Cyan */
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        .valueDisplay {
            color: #ffffff;
            font-weight: 600;
            min-width: 45px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>
<body class="bg-black text-white">
    <div id="container"></div>
    <div id="controls">
        <label for="gSlider">Gravity (G):</label>
        <input type="range" id="gSlider" min="0.1" max="10" step="0.1" value="1.0">
        <span id="gValueDisplay" class="valueDisplay">1.0</span>

        <label for="m1Slider">Mass 1:</label>
        <input type="range" id="m1Slider" class="mass1-slider" min="1" max="200" step="1" value="100">
        <span id="m1ValueDisplay" class="valueDisplay">100</span>

        <label for="m2Slider">Mass 2:</label>
        <input type="range" id="m2Slider" class="mass2-slider" min="1" max="200" step="1" value="1">
        <span id="m2ValueDisplay" class="valueDisplay">1</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let body1, body2, starField;
        let trail1, trail2;
        const MAX_TRAIL_POINTS = 500;

        // Physics parameters
        let G = 1.0;
        let m1 = 100;
        let m2 = 1;
        const dt = 0.01;

        // Initial state
        const initialG = G;
        const initialM1 = m1;
        const initialM2 = m2;

        // Place bodies relative to the initial center of mass
        const initialDistance = 22; // Slightly increased initial separation
        let pos1 = new THREE.Vector3(-initialDistance * (initialM2 / (initialM1 + initialM2)), 0, 0);
        let pos2 = new THREE.Vector3(initialDistance * (initialM1 / (initialM1 + initialM2)), 0, 0);

        // Calculate initial velocities for a more stable starting orbit
        const totalMass = initialM1 + initialM2;
        const distance = pos2.distanceTo(pos1);
        const vTotal = Math.sqrt(initialG * totalMass / distance);
        let vel1 = new THREE.Vector3(0, -vTotal * (initialM2 / totalMass) * 0.95, 0); // Adjusted factor slightly
        let vel2 = new THREE.Vector3(0, vTotal * (initialM1 / totalMass) * 0.95, 0); // Adjusted factor slightly

        // Store initial state for reset
        const initialPos1 = pos1.clone();
        const initialVel1 = vel1.clone();
        const initialPos2 = pos2.clone();
        const initialVel2 = vel2.clone();

        function init() {
            scene = new THREE.Scene();

            // --- Starfield Background ---
            createStarfield();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000); // Increased far plane for stars
            camera.position.set(0, 35, 60); // Adjusted camera position slightly
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // Enable tone mapping for better lighting/color
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('container').appendChild(renderer.domElement);

            // --- Lighting ---
            // More subtle ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            // Stronger point light for primary illumination
            const pointLight = new THREE.PointLight(0xffffff, 1.8, 1000, 2); // Color, Intensity, Distance, Decay
            pointLight.position.set(20, 40, 30);
            scene.add(pointLight);

            // --- Body Creation (Using MeshStandardMaterial) ---

            // Body 1 (Larger, "Star") - **MOVED CREATION EARLIER**
            const geometry1 = new THREE.SphereGeometry(2, 48, 48); // Increased segments for smoother sphere
             // Use MeshStandardMaterial for realistic lighting
            const material1 = new THREE.MeshStandardMaterial({
                color: 0xffd700, // Gold color
                emissive: 0xffaa00, // Stronger emissive color
                emissiveIntensity: 0.6, // Control emissive brightness
                metalness: 0.3, // Slightly metallic
                roughness: 0.4, // Moderately rough surface
            });
            body1 = new THREE.Mesh(geometry1, material1);
            body1.position.copy(pos1);
            scene.add(body1);

            // **FIX:** Add the light *after* body1 is created
            const starLight = new THREE.PointLight(0xffccaa, 0.5, 15, 2); // Warm light, low intensity
            body1.add(starLight); // Attach light to body1

            // Body 2 (Smaller, "Planet")
            const geometry2 = new THREE.SphereGeometry(0.6, 48, 48); // Increased segments, slightly larger
            const material2 = new THREE.MeshStandardMaterial({
                color: 0x0099ff, // Nice blue
                metalness: 0.1, // Less metallic
                roughness: 0.6, // Rougher surface
                // Add a very subtle emissive color if desired, e.g., for city lights effect
                // emissive: 0x001133,
                // emissiveIntensity: 0.1
            });
            body2 = new THREE.Mesh(geometry2, material2);
            body2.position.copy(pos2);
            scene.add(body2);

            // --- Orbit Trails ---
            trail1 = createTrail(0xffd700, MAX_TRAIL_POINTS); // Match body1 color
            trail2 = createTrail(0x0099ff, MAX_TRAIL_POINTS); // Match body2 color
            scene.add(trail1.line);
            scene.add(trail2.line);
            updateTrail(trail1, body1.position);
            updateTrail(trail2, body2.position);

            // --- Controls ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 300; // Increased max distance

            // --- Slider Event Listeners ---
            setupSliders();

            window.addEventListener('resize', onWindowResize, false);
        }

        function createStarfield() {
            const starQty = 10000; // Number of stars
            const positions = [];
            for (let i = 0; i < starQty; i++) {
                const x = THREE.MathUtils.randFloatSpread(1500); // Spread stars across a large area
                const y = THREE.MathUtils.randFloatSpread(1500);
                const z = THREE.MathUtils.randFloatSpread(1500);
                positions.push(x, y, z);
            }

            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7, // Adjust size of stars
                sizeAttenuation: true, // Stars farther away appear smaller
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending // Brighter where stars overlap
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        function setupSliders() {
            const gSlider = document.getElementById('gSlider');
            const gValueDisplay = document.getElementById('gValueDisplay');
            gSlider.value = G;
            gValueDisplay.textContent = G.toFixed(1);
            gSlider.addEventListener('input', (event) => {
                G = parseFloat(event.target.value);
                gValueDisplay.textContent = G.toFixed(1);
            });

            const m1Slider = document.getElementById('m1Slider');
            const m1ValueDisplay = document.getElementById('m1ValueDisplay');
            m1Slider.value = m1;
            m1ValueDisplay.textContent = m1.toFixed(0);
            m1Slider.addEventListener('input', (event) => {
                m1 = parseFloat(event.target.value);
                m1ValueDisplay.textContent = m1.toFixed(0);
                // Optional: Scale body size visually based on mass (cube root)
                const scale1 = Math.max(0.1, Math.cbrt(m1 / initialM1)); // Prevent scaling to zero
                body1.scale.set(scale1, scale1, scale1);
            });

            const m2Slider = document.getElementById('m2Slider');
            const m2ValueDisplay = document.getElementById('m2ValueDisplay');
            m2Slider.value = m2;
            m2ValueDisplay.textContent = m2.toFixed(0);
            m2Slider.addEventListener('input', (event) => {
                m2 = parseFloat(event.target.value);
                m2ValueDisplay.textContent = m2.toFixed(0);
                // Optional: Scale body size visually based on mass (cube root)
                const scale2 = Math.max(0.1, Math.cbrt(m2 / initialM2)); // Prevent scaling to zero
                body2.scale.set(scale2, scale2, scale2);
            });
             // Set initial scales based on initial masses compared to reference (initialM1/initialM2)
            const initialScale1 = Math.max(0.1, Math.cbrt(m1 / initialM1));
            body1.scale.set(initialScale1, initialScale1, initialScale1);
            const initialScale2 = Math.max(0.1, Math.cbrt(m2 / initialM2));
            body2.scale.set(initialScale2, initialScale2, initialScale2);
        }


        function createTrail(color, maxPoints) {
            const points = [];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.6 }); // Make trails slightly transparent
            const line = new THREE.Line(geometry, material);
            line.frustumCulled = false;
            return { line, geometry, points, maxPoints };
        }

        function updateTrail(trail, newPosition) {
            const { points, geometry, maxPoints } = trail;
            points.push(newPosition.clone());
            if (points.length > maxPoints) {
                points.shift();
            }
            geometry.setFromPoints(points);
            geometry.attributes.position.needsUpdate = true;
        }

        // Reset function remains the same conceptually
        function resetSimulation() {
            pos1.copy(initialPos1);
            vel1.copy(initialVel1);
            pos2.copy(initialPos2);
            vel2.copy(initialVel2);

            // Keep current slider values for G, m1, m2
            body1.position.copy(pos1);
            body2.position.copy(pos2);

            // Reset visual scale based on current slider mass vs initial mass
            const scale1 = Math.max(0.1, Math.cbrt(m1 / initialM1));
            body1.scale.set(scale1, scale1, scale1);
            const scale2 = Math.max(0.1, Math.cbrt(m2 / initialM2));
            body2.scale.set(scale2, scale2, scale2);

            // Reset trails
            trail1.points = [pos1.clone()];
            trail2.points = [pos2.clone()];
            trail1.geometry.setFromPoints(trail1.points);
            trail2.geometry.setFromPoints(trail2.points);
            trail1.geometry.attributes.position.needsUpdate = true;
            trail2.geometry.attributes.position.needsUpdate = true;

            console.log("Simulation Reset (Positions/Velocities)");
        }


        function updatePhysics() {
            const rVec = new THREE.Vector3().subVectors(pos2, pos1);
            const rMagSq = rVec.lengthSq();

            // Calculate approximate collision threshold based on current visual size
            // Use geometry radius and current scale
            const radius1 = body1.geometry.parameters.radius * body1.scale.x;
            const radius2 = body2.geometry.parameters.radius * body2.scale.x;
            const collisionThresholdSq = (radius1 + radius2) * (radius1 + radius2) * 1.1; // Approx sum of radii squared + buffer

             if (rMagSq < Math.max(0.5, collisionThresholdSq)) { // Use dynamic threshold or minimum distance
                 // Optional: Implement collision logic (e.g., merge, bounce) or just stop physics update
                 // console.log("Collision detected (or very close)"); // Avoid spamming console
                 return; // Stop physics update if too close
             }


            if (m1 <= 0 || m2 <= 0) return;
            const fMag = (G * m1 * m2) / rMagSq;
            const fVec = rVec.normalize().multiplyScalar(fMag);

            const acc1 = new THREE.Vector3().copy(fVec).divideScalar(m1);
            const acc2 = new THREE.Vector3().copy(fVec).divideScalar(m2).negate();

            vel1.addScaledVector(acc1, dt);
            vel2.addScaledVector(acc2, dt);

            pos1.addScaledVector(vel1, dt);
            pos2.addScaledVector(vel2, dt);

            body1.position.copy(pos1);
            body2.position.copy(pos2);

            updateTrail(trail1, body1.position);
            updateTrail(trail2, body2.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotate starfield slowly for a dynamic background effect
            if (starField) {
                starField.rotation.y += 0.0001;
                starField.rotation.x += 0.00005;
            }

            updatePhysics();
            controls.update();
            renderer.render(scene, camera);
        }

        window.onload = () => {
            init();
            animate();
        };

    </script>
</body>
</html>
