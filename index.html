<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Body Gravitational Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(40, 40, 40, 0.85); /* Slightly darker background */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: grid; /* Use grid for better alignment */
            grid-template-columns: auto 1fr auto; /* Label, Slider, Value */
            align-items: center;
            gap: 10px 15px; /* Row gap, Column gap */
            width: 90%;
            max-width: 450px; /* Slightly wider */
        }
        label {
            color: #e0e0e0;
            font-weight: 500;
            white-space: nowrap;
            text-align: right; /* Align labels right */
        }
        /* Custom Slider Styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, #4a90e2, #8e44ad); /* Gradient for G */
            border-radius: 5px;
            cursor: pointer;
            outline: none;
            transition: background .3s; /* Smooth transition for background */
        }
        /* Specific background gradients for mass sliders */
        input[type="range"].mass1-slider {
             background: linear-gradient(90deg, #ffcc00, #ff6600); /* Yellow/Orange gradient */
        }
         input[type="range"].mass2-slider {
             background: linear-gradient(90deg, #0077ff, #00ccff); /* Blue/Cyan gradient */
        }

        /* Thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        .valueDisplay { /* Class for value spans */
            color: #ffffff;
            font-weight: 600;
            min-width: 45px; /* Ensure space for value */
            text-align: right;
            font-variant-numeric: tabular-nums; /* Keep numbers aligned */
        }
    </style>
</head>
<body class="bg-black text-white">
    <div id="container"></div>
    <div id="controls">
        <label for="gSlider">Gravity (G):</label>
        <input type="range" id="gSlider" min="0.1" max="10" step="0.1" value="1.0">
        <span id="gValueDisplay" class="valueDisplay">1.0</span>

        <label for="m1Slider">Mass 1:</label>
        <input type="range" id="m1Slider" class="mass1-slider" min="1" max="200" step="1" value="100">
        <span id="m1ValueDisplay" class="valueDisplay">100</span>

        <label for="m2Slider">Mass 2:</label>
        <input type="range" id="m2Slider" class="mass2-slider" min="1" max="200" step="1" value="1">
        <span id="m2ValueDisplay" class="valueDisplay">1</span>
    </div>

    <script type="module">
        // Import necessary modules using paths defined in importmap
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let body1, body2;
        let trail1, trail2;
        const MAX_TRAIL_POINTS = 500;

        // Physics parameters (now controllable via sliders)
        let G = 1.0;
        let m1 = 100; // Initial mass of body 1
        let m2 = 1;   // Initial mass of body 2
        const dt = 0.01; // Time step for simulation

        // Initial state (positions are Vector3, velocities are Vector3)
        // Velocities depend on initial masses and G
        const initialG = G;
        const initialM1 = m1;
        const initialM2 = m2; // Store initial masses too

        let pos1 = new THREE.Vector3(-2 * (initialM2 / (initialM1 + initialM2)), 0, 0); // Position relative to center of mass
        let pos2 = new THREE.Vector3(20 * (initialM1 / (initialM1 + initialM2)), 0, 0); // Position relative to center of mass

        // Calculate initial velocities for a more stable starting orbit if possible
        // This is a simplified approach, assuming circular orbit initially for velocity calculation
        const totalMass = initialM1 + initialM2;
        const distance = pos2.distanceTo(pos1);
        // Approximate orbital speed v = sqrt(G * M_total / r) - split between bodies based on mass ratio
        const vTotal = Math.sqrt(initialG * totalMass / distance);
        let vel1 = new THREE.Vector3(0, -vTotal * (initialM2 / totalMass) * 0.9, 0); // Assign velocity inversely proportional to mass
        let vel2 = new THREE.Vector3(0, vTotal * (initialM1 / totalMass) * 0.9, 0); // *0.9 to make it slightly elliptical


        // Store initial state for reset
        const initialPos1 = pos1.clone();
        const initialVel1 = vel1.clone();
        const initialPos2 = pos2.clone();
        const initialVel2 = vel2.clone();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 50);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1.5, 500);
            pointLight.position.set(10, 30, 20);
            scene.add(pointLight);

            // Body 1 (Yellow)
            const geometry1 = new THREE.SphereGeometry(2, 32, 32); // Initial size
            const material1 = new THREE.MeshPhongMaterial({ color: 0xffcc00, emissive: 0xaa8800, shininess: 50 });
            body1 = new THREE.Mesh(geometry1, material1);
            body1.position.copy(pos1);
            scene.add(body1);

            // Body 2 (Blue)
            const geometry2 = new THREE.SphereGeometry(0.5, 32, 32); // Initial size
            const material2 = new THREE.MeshPhongMaterial({ color: 0x0077ff, shininess: 80 });
            body2 = new THREE.Mesh(geometry2, material2);
            body2.position.copy(pos2);
            scene.add(body2);

            // Orbit Trails
            trail1 = createTrail(0xffcc00, MAX_TRAIL_POINTS);
            trail2 = createTrail(0x0077ff, MAX_TRAIL_POINTS);
            scene.add(trail1.line);
            scene.add(trail2.line);
            updateTrail(trail1, body1.position);
            updateTrail(trail2, body2.position);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 200;

            // --- Slider Event Listeners ---
            const gSlider = document.getElementById('gSlider');
            const gValueDisplay = document.getElementById('gValueDisplay');
            gSlider.value = G; // Set initial value
            gValueDisplay.textContent = G.toFixed(1);
            gSlider.addEventListener('input', (event) => {
                G = parseFloat(event.target.value);
                gValueDisplay.textContent = G.toFixed(1);
                // Note: Changing G dynamically affects stability. Consider resetting.
            });

            const m1Slider = document.getElementById('m1Slider');
            const m1ValueDisplay = document.getElementById('m1ValueDisplay');
            m1Slider.value = m1; // Set initial value
            m1ValueDisplay.textContent = m1;
            m1Slider.addEventListener('input', (event) => {
                m1 = parseFloat(event.target.value);
                m1ValueDisplay.textContent = m1.toFixed(0);
                // Optional: Adjust body size based on mass?
                // const scale1 = Math.cbrt(m1 / initialM1); // Scale by cube root of mass ratio
                // body1.scale.set(scale1, scale1, scale1);
                // Note: Changing mass dynamically significantly affects stability. Consider resetting.
            });

            const m2Slider = document.getElementById('m2Slider');
            const m2ValueDisplay = document.getElementById('m2ValueDisplay');
            m2Slider.value = m2; // Set initial value
            m2ValueDisplay.textContent = m2;
            m2Slider.addEventListener('input', (event) => {
                m2 = parseFloat(event.target.value);
                m2ValueDisplay.textContent = m2.toFixed(0);
                 // Optional: Adjust body size based on mass?
                // const scale2 = Math.cbrt(m2 / initialM2); // Scale by cube root of mass ratio
                // body2.scale.set(scale2, scale2, scale2);
                // Note: Changing mass dynamically significantly affects stability. Consider resetting.
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        function createTrail(color, maxPoints) {
            const points = [];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color });
            const line = new THREE.Line(geometry, material);
            line.frustumCulled = false;
            return { line, geometry, points, maxPoints };
        }

        function updateTrail(trail, newPosition) {
            const { points, geometry, maxPoints } = trail;
            points.push(newPosition.clone());
            if (points.length > maxPoints) {
                points.shift();
            }
            geometry.setFromPoints(points);
            geometry.attributes.position.needsUpdate = true;
        }

        // Reset function (optional, could be triggered by a button)
        function resetSimulation() {
            pos1.copy(initialPos1);
            vel1.copy(initialVel1);
            pos2.copy(initialPos2);
            vel2.copy(initialVel2);

            // Reset masses and G to their initial values? Or keep slider values?
            // Let's keep current slider values for G, m1, m2 for now.
            // G = initialG;
            // m1 = initialM1;
            // m2 = initialM2;
            // gSlider.value = G; gValueDisplay.textContent = G.toFixed(1);
            // m1Slider.value = m1; m1ValueDisplay.textContent = m1.toFixed(0);
            // m2Slider.value = m2; m2ValueDisplay.textContent = m2.toFixed(0);


            body1.position.copy(pos1);
            body2.position.copy(pos2);

            // Reset trails
            trail1.points = [pos1.clone()];
            trail2.points = [pos2.clone()];
            trail1.geometry.setFromPoints(trail1.points);
            trail2.geometry.setFromPoints(trail2.points);
            trail1.geometry.attributes.position.needsUpdate = true;
            trail2.geometry.attributes.position.needsUpdate = true;

            console.log("Simulation Reset (Positions/Velocities)");
        }


        function updatePhysics() {
            // Calculate distance vector and squared magnitude
            const rVec = new THREE.Vector3().subVectors(pos2, pos1);
            const rMagSq = rVec.lengthSq();

            // Prevent instability at close distances
            if (rMagSq < 0.1) return; // Increased threshold slightly

            // Calculate gravitational force magnitude (F = G * m1 * m2 / r^2)
            // Ensure masses are not zero to avoid division issues, though sliders prevent this.
            if (m1 <= 0 || m2 <= 0) return;
            const fMag = (G * m1 * m2) / rMagSq;

            // Calculate force vector (normalized distance vector * force magnitude)
            const fVec = rVec.normalize().multiplyScalar(fMag); // rVec is modified here

            // Calculate acceleration (a = F / m)
            const acc1 = new THREE.Vector3().copy(fVec).divideScalar(m1);
            const acc2 = new THREE.Vector3().copy(fVec).divideScalar(m2).negate();

            // Update velocities (v = v0 + a * dt)
            vel1.addScaledVector(acc1, dt);
            vel2.addScaledVector(acc2, dt);

            // Update positions (p = p0 + v * dt)
            pos1.addScaledVector(vel1, dt);
            pos2.addScaledVector(vel2, dt);

            // Update mesh positions
            body1.position.copy(pos1);
            body2.position.copy(pos2);

            // Update trails
            updateTrail(trail1, body1.position);
            updateTrail(trail2, body2.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            controls.update();
            renderer.render(scene, camera);
        }

        // Start after DOM is loaded
        window.onload = () => {
            init();
            animate();
        };

    </script>
</body>
</html>
