<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Two-Body Gravitational Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(40, 40, 40, 0.85);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: grid;
            grid-template-columns: auto 1fr auto; /* Label, Slider, Value */
            align-items: center;
            gap: 10px 15px;
            width: 90%;
            max-width: 500px; /* Increased max-width slightly */
        }
        label {
            color: #e0e0e0;
            font-weight: 500;
            white-space: nowrap;
            text-align: right;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, #4a90e2, #8e44ad); /* Default for G */
            border-radius: 5px;
            cursor: pointer;
            outline: none;
            transition: background .3s;
        }
        input[type="range"].mass1-slider {
             background: linear-gradient(90deg, #ffdf80, #ff8c1a); /* Brighter Yellow/Orange */
        }
         input[type="range"].mass2-slider {
             background: linear-gradient(90deg, #6bbdff, #0099e6); /* Brighter Blue/Cyan */
        }
         /* Style for the new speed slider */
         input[type="range"].speed-slider {
             background: linear-gradient(90deg, #4caf50, #cddc39); /* Green/Lime gradient */
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #ffffff;
            border-radius: 50%;
            border: 2px solid #555;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        .valueDisplay {
            color: #ffffff;
            font-weight: 600;
            min-width: 45px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>
<body class="bg-black text-white">
    <div id="container"></div>
    <div id="controls">
        <label for="gSlider">Gravity (G):</label>
        <input type="range" id="gSlider" min="0.1" max="10" step="0.1" value="1.0">
        <span id="gValueDisplay" class="valueDisplay">1.0</span>

        <label for="m1Slider">Mass 1:</label>
        <input type="range" id="m1Slider" class="mass1-slider" min="1" max="200" step="1" value="100">
        <span id="m1ValueDisplay" class="valueDisplay">100</span>

        <label for="m2Slider">Mass 2:</label>
        <input type="range" id="m2Slider" class="mass2-slider" min="1" max="200" step="1" value="1">
        <span id="m2ValueDisplay" class="valueDisplay">1</span>

        <label for="speedSlider">Speed:</label>
        <input type="range" id="speedSlider" class="speed-slider" min="0.1" max="10" step="0.1" value="1.0">
        <span id="speedValueDisplay" class="valueDisplay">1.0x</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let body1, body2, starField;
        let trail1, trail2;
        const MAX_TRAIL_POINTS = 500;

        // Physics parameters
        let G = 1.0;
        let m1 = 100;
        let m2 = 1;
        const dt = 0.01; // Base time step
        let simulationSpeed = 1.0; // Simulation speed multiplier

        // Initial state
        const initialG = G;
        const initialM1 = m1;
        const initialM2 = m2;

        // Place bodies relative to the initial center of mass
        const initialDistance = 22;
        let pos1 = new THREE.Vector3(-initialDistance * (initialM2 / (initialM1 + initialM2)), 0, 0);
        let pos2 = new THREE.Vector3(initialDistance * (initialM1 / (initialM1 + initialM2)), 0, 0);

        // Calculate initial velocities
        const totalMass = initialM1 + initialM2;
        const distance = pos2.distanceTo(pos1);
        const vTotal = Math.sqrt(initialG * totalMass / distance);
        let vel1 = new THREE.Vector3(0, -vTotal * (initialM2 / totalMass) * 0.95, 0);
        let vel2 = new THREE.Vector3(0, vTotal * (initialM1 / totalMass) * 0.95, 0);

        // Store initial state for reset
        const initialPos1 = pos1.clone();
        const initialVel1 = vel1.clone();
        const initialPos2 = pos2.clone();
        const initialVel2 = vel2.clone();

        function init() {
            scene = new THREE.Scene();

            // --- Starfield Background ---
            createStarfield();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 35, 60);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('container').appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1.8, 1000, 2);
            pointLight.position.set(20, 40, 30);
            scene.add(pointLight);

            // --- Body Creation ---
            // Body 1
            const geometry1 = new THREE.SphereGeometry(2, 48, 48);
            const material1 = new THREE.MeshStandardMaterial({
                color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 0.6,
                metalness: 0.3, roughness: 0.4,
            });
            body1 = new THREE.Mesh(geometry1, material1);
            body1.position.copy(pos1);
            scene.add(body1);
            const starLight = new THREE.PointLight(0xffccaa, 0.5, 15, 2);
            body1.add(starLight);

            // Body 2
            const geometry2 = new THREE.SphereGeometry(0.6, 48, 48);
            const material2 = new THREE.MeshStandardMaterial({
                color: 0x0099ff, metalness: 0.1, roughness: 0.6,
            });
            body2 = new THREE.Mesh(geometry2, material2);
            body2.position.copy(pos2);
            scene.add(body2);

            // --- Orbit Trails ---
            trail1 = createTrail(0xffd700, MAX_TRAIL_POINTS);
            trail2 = createTrail(0x0099ff, MAX_TRAIL_POINTS);
            scene.add(trail1.line);
            scene.add(trail2.line);
            updateTrail(trail1, body1.position);
            updateTrail(trail2, body2.position);

            // --- Controls ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 300;

            // --- Slider Event Listeners ---
            setupSliders(); // Sets up all sliders including the new speed slider

            window.addEventListener('resize', onWindowResize, false);
        }

        function createStarfield() {
            const starQty = 10000;
            const positions = [];
            for (let i = 0; i < starQty; i++) {
                const x = THREE.MathUtils.randFloatSpread(1500);
                const y = THREE.MathUtils.randFloatSpread(1500);
                const z = THREE.MathUtils.randFloatSpread(1500);
                positions.push(x, y, z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff, size: 0.7, sizeAttenuation: true,
                transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
            });
            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        function setupSliders() {
            // Gravity Slider
            const gSlider = document.getElementById('gSlider');
            const gValueDisplay = document.getElementById('gValueDisplay');
            gSlider.value = G;
            gValueDisplay.textContent = G.toFixed(1);
            gSlider.addEventListener('input', (event) => {
                G = parseFloat(event.target.value);
                gValueDisplay.textContent = G.toFixed(1);
            });

            // Mass 1 Slider
            const m1Slider = document.getElementById('m1Slider');
            const m1ValueDisplay = document.getElementById('m1ValueDisplay');
            m1Slider.value = m1;
            m1ValueDisplay.textContent = m1.toFixed(0);
            m1Slider.addEventListener('input', (event) => {
                m1 = parseFloat(event.target.value);
                m1ValueDisplay.textContent = m1.toFixed(0);
                const scale1 = Math.max(0.1, Math.cbrt(m1 / initialM1));
                body1.scale.set(scale1, scale1, scale1);
            });

            // Mass 2 Slider
            const m2Slider = document.getElementById('m2Slider');
            const m2ValueDisplay = document.getElementById('m2ValueDisplay');
            m2Slider.value = m2;
            m2ValueDisplay.textContent = m2.toFixed(0);
            m2Slider.addEventListener('input', (event) => {
                m2 = parseFloat(event.target.value);
                m2ValueDisplay.textContent = m2.toFixed(0);
                const scale2 = Math.max(0.1, Math.cbrt(m2 / initialM2));
                body2.scale.set(scale2, scale2, scale2);
            });

            // Speed Slider -- NEW --
            const speedSlider = document.getElementById('speedSlider');
            const speedValueDisplay = document.getElementById('speedValueDisplay');
            speedSlider.value = simulationSpeed; // Set initial value
            speedValueDisplay.textContent = simulationSpeed.toFixed(1) + 'x'; // Set initial display text
            speedSlider.addEventListener('input', (event) => {
                simulationSpeed = parseFloat(event.target.value);
                speedValueDisplay.textContent = simulationSpeed.toFixed(1) + 'x'; // Update display text
            });

            // Set initial visual scales
            const initialScale1 = Math.max(0.1, Math.cbrt(m1 / initialM1));
            body1.scale.set(initialScale1, initialScale1, initialScale1);
            const initialScale2 = Math.max(0.1, Math.cbrt(m2 / initialM2));
            body2.scale.set(initialScale2, initialScale2, initialScale2);
        }


        function createTrail(color, maxPoints) {
            const points = [];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
            const line = new THREE.Line(geometry, material);
            line.frustumCulled = false;
            return { line, geometry, points, maxPoints };
        }

        function updateTrail(trail, newPosition) {
            const { points, geometry, maxPoints } = trail;
            points.push(newPosition.clone());
            if (points.length > maxPoints) {
                points.shift();
            }
            geometry.setFromPoints(points);
            geometry.attributes.position.needsUpdate = true;
        }

        function resetSimulation() {
            // Reset physics state
            pos1.copy(initialPos1);
            vel1.copy(initialVel1);
            pos2.copy(initialPos2);
            vel2.copy(initialVel2);

            // Keep current slider values for G, m1, m2, and speed
            body1.position.copy(pos1);
            body2.position.copy(pos2);

            // Reset visual scale based on current slider mass vs initial mass
            const scale1 = Math.max(0.1, Math.cbrt(m1 / initialM1));
            body1.scale.set(scale1, scale1, scale1);
            const scale2 = Math.max(0.1, Math.cbrt(m2 / initialM2));
            body2.scale.set(scale2, scale2, scale2);

            // Reset trails
            trail1.points = [pos1.clone()];
            trail2.points = [pos2.clone()];
            trail1.geometry.setFromPoints(trail1.points);
            trail2.geometry.setFromPoints(trail2.points);
            trail1.geometry.attributes.position.needsUpdate = true;
            trail2.geometry.attributes.position.needsUpdate = true;

            console.log("Simulation Reset (Positions/Velocities)");
        }


        function updatePhysics() {
            // Calculate effective time step based on speed slider
            const effectiveDt = dt * simulationSpeed;

            const rVec = new THREE.Vector3().subVectors(pos2, pos1);
            const rMagSq = rVec.lengthSq();

            // Collision detection/avoidance
            const radius1 = body1.geometry.parameters.radius * body1.scale.x;
            const radius2 = body2.geometry.parameters.radius * body2.scale.x;
            const collisionThresholdSq = (radius1 + radius2) * (radius1 + radius2) * 1.1;
            if (rMagSq < Math.max(0.5, collisionThresholdSq)) {
                 return; // Stop physics update if too close
            }

            // Calculate forces and accelerations
            if (m1 <= 0 || m2 <= 0) return;
            const fMag = (G * m1 * m2) / rMagSq;
            const fVec = rVec.normalize().multiplyScalar(fMag);
            const acc1 = new THREE.Vector3().copy(fVec).divideScalar(m1);
            const acc2 = new THREE.Vector3().copy(fVec).divideScalar(m2).negate();

            // Update velocities using effective time step
            vel1.addScaledVector(acc1, effectiveDt);
            vel2.addScaledVector(acc2, effectiveDt);

            // Update positions using effective time step
            pos1.addScaledVector(vel1, effectiveDt);
            pos2.addScaledVector(vel2, effectiveDt);

            // Update mesh positions
            body1.position.copy(pos1);
            body2.position.copy(pos2);

            // Update trails
            updateTrail(trail1, body1.position);
            updateTrail(trail2, body2.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotate starfield slowly
            if (starField) {
                starField.rotation.y += 0.0001;
                starField.rotation.x += 0.00005;
            }

            // Update physics based on current speed setting
            updatePhysics();

            // Update camera controls
            controls.update();

            // Render the scene
            renderer.render(scene, camera);
        }

        // Initialize and start animation on window load
        window.onload = () => {
            init();
            animate();
        };

    </script>
</body>
</html>
